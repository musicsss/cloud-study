# 第二十章 注解

注解（也被称为元数据）为我们在代码中添加信息提供了一种形式化的方法，使我们可以在稍后的某个时刻非常方便地使用这些数据。

注解在一定程度上是把元数据与源文件文件结合在一起，而不是保存在外部文档中这一大的趋势之下所催生。

注解是众多引入到Java SE5中的重要的语言变化之一。它们可以提供用来完整地描述程序所需的信息，而这些信息是无法用Java来表达的。
因此注解使得我们能够以将由编译器来测试和验证的格式，存储有关程序的额外信息。注解可以用来生成描述符文件，甚至或是新的类定义，并且有助于减轻编写
"样板"代码的负担。通过注解，我们可以将这些元数据保存在Java源代码中，并利用annotation API为自己的注解构造处理工具，同时，注解的优点还包括：
更加干净易于阅读的代码以及编译期类型检查等。虽然Java SE5预先定义了一些元数据，但一般来说，主要还是需要程序员自己添加新的注解，并且按自己的方式使用它们。

注解语法简单，除了@符号的使用之外，它基本与Java固有的语法一直。Java SE5内置了三种，定义在java.lang中的注解：

+ @Override，表示当前的方法定义将覆盖超类中的方法。如果不小心拼写错误，或者方法签名对不上被覆盖的方法，编译器就会发出错误提示
+ @Deprecated，如果程序源使用了注解为它的元素，那么编译器会发出警告信息。
+ @SuppressWarnings，关闭不当的编译器警告信息。在Java SE5之前的版本中，也可以使用该注解，不过会被忽略不起作用。

当创建描述符性质的类或接口时，一旦其中包含了重复性的工作，那就可以考虑使用注解来简化与自动化该过程。

注解（annotation）是在实际的源代码级别保存所有的信息，而不是某种注释性的文字（comment），这使得代码更加整洁，且便于维护。

通过使用扩展的annotation API，或外部的字节码工具类库，程序员拥有对源代码以及字节码强大的检查与操作能力。

## 20.1 基本语法

被注解的方法与其他的方法没有区别。注解可以与任何修饰符共同作用于方法。从语法的角度来看，注解的使用方式几乎与修饰符的使用一模一样。

### 20.1.1 定义注解

注解的定义类似于接口的定义。和其他任何Java接口一样，注解也将会编译成class文件。

定义注解时，需要一些元注解(meta-annotation)，如@Target和@Retention。@Target用来定义注解将用于什么地方（例如是一个方法或者一个域）。

@Rectetion用来定义该注解在哪一个级别可用，在源代码中(SOURCE)、类文件中(CLASS)或者运行时(RUNTIME).

在注解中，一般都会包含一些元素以表示某些值。当分析处理注解时，程序或工具可以利用这些值。
注解的元素看起来就像接口的方法，唯一的区别是可以为其指定默认值（Java 1.8 以可以为接口指定默认值）。

没有元素的注解称为标记注解(marker annotation)

### 20.1.2 元注解

Java目前只提供了三种标准注解，以及四种元注解。元注解专职负责注解其他的注解：

+ @Target： 表示该注解可以用于什么地方。可能的ElementType包括
  + CONSTRUCTOR：构造器的声明
  + FIELD：域声明（包括enum实例）
  + LOCAL_VARIABLE：局部变量声明
  + METHOD：方法声明
  + PACKAGE：包声明
  + PARAMETER：参数声明
  + TYPE：类、接口（包括注解类型）或enum声明
+ Retention：表示需要在什么级别保存该注解信息。可选的RetentionPolicy参数包括：
  + SOURCE：注解将被编译器丢弃
  + CLASS：注解在class文件中可用，但会被VM丢弃。
  + RUNTIME：VM将在运行期也保留注解，因此可以通过反射机制读取注解的信息。
+ Documented: 此注解包含在Javadoc中。
+ Inherited：允许子类继承父类中的注解。

大多数时候，主要是定义自己的注解，并编写自己的处理器来处理它们。

## 20.2 编写注解处理器

如果没有用来读取注解的工具，那注解就是注释。在使用注解的过程中，很重要的一个部分就是创建与使用注解处理器。
Java SE5扩展了反射机制的API，以帮助程序员构造这类工具。同时它还提供了一个外部工具apt帮助程序员解析带有注解的Java源代码

getAnnoation()方法返回指定类型的注解对象，如果被注解的方法上没有该类型的注解，则返回null值。

### 20.2.1 注解元素
注解元素可用的类型如下所示：
+ 所有基本类型（int,float,boolean等)
+ String
+ Class
+ enum
+ Anotation
+ 以上类型的数组

如果使用了其它类型，编译器将会报错。注意，也不允许使用任何包装类型，不过由于自动打包的存在，这也不算什么限制。
注解也可以作为元素的类型，也就是说注解可以嵌套

### 20.2.2 默认值限制

编译器对元素的默认值有些过分的挑剔。首先，元素不能由不确定的值，也就是说，元素必须要有默认值，要么在使用注解时提供元素的值。

其次，对于非基本类型的元素，无论是在源代码中声明时，或是在注解接口中定义默认值时，都不能以null作为其值。
这个约束使得处理器很难表现一个元素的存在或缺失的状态，因为在每个注解中，所有的元素都存在，并且都具有相应的值。
为了绕开这个约束，我们只能自己定义一些特殊的值，例如空字符串或负数，以此表示某个元素不存在。在定义注解的时候，这是一个习惯用法。

### 生成外部文件

有些framework需要一些额外的信息才能与源代码协同工作，而这种情况最适合注解表现其价值了。类似（EJB3之前）Enterprise JavaBean这样的技术，
每一个Bean都需要大量的接口和部署来描述文件，而这些都属于”样板“文件。Web Service、自定义标签库以及对象/关系映射工具（例如Toplink和Hibernate）等，
一般都需要XML描述文件，而这些描述文件脱离于源代码之外。因此，在定义了Java类之后，程序员还必须得忍受着沉闷，重复地提供某些信息，例如类名和包名等已经在
原始的类文件中提供了的信息。每当程序员使用外部描述文件时，其就必须拥有了同一个类的两个单独的信息源，这经常导致代码同步问题。同时，其也要求为项目工作的
程序员，必须同时知道如何编写Java程序，以及如何编辑描述文件。

假设希望提供一些基本的对象/关系映射功能，能够自动生成数据库表，以及存储JavaBean对象。可以选择使用XML描述文件，指明类的名字、每个成员以及数据库映射的相关信息。
然而，如果使用注解的话，可以将所有信息都保存在JavaBean源文件中。为此，需要一些新的注解，用以定义与Bean关联的数据库表的名字，以及与Bean属性关联的列的名字和SQL类型。

在@Target 注解中指定的每一个ElementType就是一个约束，其告诉编译器，这个自定义的注解只能应用于该类型。程序员可以只指定enum ElementType中的某一个
值，或者以都好分隔的形式指定多个值。如果像哟啊将注解应用于所有的ElementType，那么可以省去@Target元注解，不过这并不常见。